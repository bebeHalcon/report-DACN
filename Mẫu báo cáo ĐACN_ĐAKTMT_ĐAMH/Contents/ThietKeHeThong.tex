\section{Thiết kế hệ thống}
\subsection{Thiết kế cơ sở dữ liệu sử dụng cho màn chơi}
\hspace*{0.5cm} Cơ chế chơi chính của trò chơi là sử dụng một Cơ sở dữ liệu do game cung cấp, tận dụng thông tin thu thập được từ cơ sở dữ liệu cũng như sử dụng chính các câu truy vấn này để thực hiện các hành động trong màn chơi, khi đối đầu với kẻ thù. Một trong những thứ không thể thiếu của game là cơ sở dữ liệu của trò chơi. Người chơi sẽ sử dụng các câu truy vấn SQL để khai thác tối đa SQL, tìm được mục tiêu và tiêu diệt chúng. Bản chất của Cơ sở dữ liệu sử dụng trong game được xem như một phần của giao diện, là cầu nối để người chơi tương tác với game, không được sử dụng để lưu trữ thông tin dài hạn như các hệ thống sử dụng cơ sở dữ liệu khác. Trạng thái của màn chơi hiện tại cũng ánh xạ một phàn vào trạng thái của Cơ sở dữ liệu sử dụng trong màn chơi\\
\hspace*{0.5cm} Để thiết kế và hiện thực cơ sở dữ liệu để đưa vào trò chơi cho người chơi tương tác, nhóm trải qua các giai đoạn tương tự với các giai đoạn của việc thiết kế cơ sở dữ liệu thường được áp dụng.
\subsubsection{Giai đoạn 1: Thu thập và phân tích yêu cầu nghiệp vụ}
\hspace*{0.5cm} Căn cứ vào các yêu cầu chức năng, phi chức năng và cơ chế gameplay chính của trò chơi, nhóm cũng thu thập, phân tích và đúc kết được một số yêu cầu cho cơ sở dữ liệu của màn chơi.
\begin{itemize}
	\item Thực thể trong màn chơi là thực thể sẽ được tồn tại với một mã định danh (ID) là chuỗi 8 ký tự, bao gồm chữ cái thường hoặc chữ số, đi kèm với đó là tên của thực thể và mô tả của thực thể đó, tên và mô tả có thể không có dữ liệu. Thực thể có thể là Người chơi, Quái vật, bộ phận quái vật và thực thể khác, mỗi thực thể không thể mang 2 loại, ví dụ như người chơi không thể là quái vật. Thực thể có thể không là 1 trong 3 loại trên, nó có thể là các vật thể tồn tại trong môi trường của màn chơi và khu vực chiến đấu.
	
	\item Người chơi là dạng thực thể sẽ được điều khiển của người dùng. Người chơi gồm trạng thái hiện tại của người chơi, bao gồm HP hiện tại cũng như HP tối đa, cùng cấp độ hiện tại của người chơi. Người chơi cũng có một bộ Thông số hiện tại, để người chơi có thể theo dõi. Người chơi cũng có các trạng thái về hiệu ứng hiện tại, bao gồm hiệu ứng lửa, độc, mù, băng, hiệu ứng câu lệnh,.... Người chơi cũng có Inventory chứa các vật phẩm cũng như các slot trang bị dành cho người chơi.
	
	\item Vật phẩm của trò chơi là các vật phẩm được sử dụng trong trò chơi và màn chơi. Vật phẩm phải có một mã định danh riêng biệt cho vật phẩm là một chuỗi có 7 kí tự gồm số và chữ cái thường, cùng tên và mô tả. Vật phẩm có thể là trang bị, vật phẩm sử dụng được, hoặc không thuộc loại nào. Vật phẩm chỉ có thể là trang bị, hoặc là vật phẩm, không thể vừa là trang bị vừa là vật phẩm tiêu thụ được. Vật phẩm có thể nằm trong Inventory hoặc không, Có thể có nhiều vật phẩm nằm trong Inventory của người chơi.
	
	\item Trang bị là một loại vật phẩm, người chơi có các slot trang bị nhất định. Mỗi món trang bị sẽ có từ 1-3 traits, được tổng hợp lại cho người chơi để xét mỗi khi quái vật tấn công hoặc ảnh hưởng của môi trường. Mỗi món trang bị chỉ có thể ở trong kho đồ với số lượng là 1. Các món trang bị có thể thuộc các loại khác nhau nhưng nó vẫn cùng chung một cấu trúc bộ chỉ số. Các món trang bị có các chỉ số cơ bản là cấp độ trang bị hiện tại và yêu cầu cấp độ người chơi để có thể trang bị được món trang bị. Ngoài ra, trang bị cũng mang bộ chỉ số hiện tại
	
	\item Vật phẩm sử dụng được là vật phẩm người chơi có thể sử dụng được, mang lại các lợi ích cho người chơi. Các thông số của món vật phẩm bao gồm: Hồi máu, giảm hiệu ứng, và các thông số tăng cường như tấn công, phòng thủ và nhanh nhẹn.
	
	\item Các kỹ năng có thể được sử dụng bởi Quái vật và cả người chơi, mỗi kỹ năng phân biệt nhau bằng một chuỗi 6 ký tự gồm số và ký tự thường. Quái vật và người chơi đều có trạng thái hồi kỹ năng. Các kỹ năng bao gồm tên, mô tả và bộ thông số tính thêm khi sử dụng. Khi thực hiện đòn đánh với kỹ năng, hệ thống sẽ tổng hợp các tham số cơ bản của trang bị và tham số cộng thêm của đòn đánh, rồi tính thêm chỉ số tấn công phép vào sát thương cuối cùng. Kỹ năng cũng có thể là kỹ năng áp dụng được lên bản thân người thi triển, giúp hồi máu, giảm hiệu ứng hoặc gia tăng các chỉ số. Mỗi kỹ năng cũng sẽ có tối đa 2 traits để xét độ hiệu quả của kỹ năng.
	
	\item Bộ thông số được sử dụng chung cho Người chơi, quái vật, trang bị, kỹ năng quái vật và của trang bị. Cấu trúc khoá bao gồm mã định danh của thực thể, hoặc trang bị, hoặc mã kỹ năng của quái vật, hoặc mã trang bị + index của kỹ năng, và mục đích sử dụng bộ thông số này. Mục đích sử dụng được viết theo dạng xâu, ví dụ như "Current" chỉ thông số hiện tai, "Max" chỉ thông số tối đa, "Modify" chỉ thông số sẽ thay đổi (thường được sử dụng cho các kỹ năng của quái vật và kỹ năng của trang bị được trang bị trong slot). Thông số bao gồm chỉ số tấn công, phòng thủ, nhanh nhẹn, sát thương phép, máu tối đa có thể mang lại, thay đổi máu, tỉ lệ chí mạng, khuếch đại chí mạng, hút máu và các sát thương hiệu ứng tấn công và kháng hiệu ứng, bao gồm hiệu ứng lửa, độc, mù, băng. Với một chủ và mục đích sử dụng chỉ có duy nhất 1 bộ thông số, các thực thể có thể phải có 1 bộ thông số với các mục đích khác nhau. 
	
	\item Quái vật là thực thể, là kẻ thù của người chơi. Quái vật có các thông số tương tự người chơi, chỉ có điều quái vật không có túi đồ và trang bị. Quái vật vẫn có bộ thông số hiện tại tương tự với bộ thông số đã được đề cập ở trên. Quái vật chỉ thuộc một chủng loại Quái vật, một Loại Quái vật có thể có nhiều quái vật thuộc loại. Loại Quái vật gồm có tên loại là duy nhất. Mỗi Loại quái vật còn đi kèm một bộ gồm một số kỹ năng của quái vật. Cấu trúc kỹ năng tương tự với kỹ năng của người chơi. Mỗi kỹ năng có thể thuộc nhiều loại quái vật khác nhau. Quái vật có thể chọn một số kỹ năng của loại quái vật làm kỹ năng cho mình (quái vật không nhất thiết phải chọn toàn bộ kỹ năng tương ứng với loại quái vật). Loại Quái vật cũng có tối đa 1 Trait được sử dụng cho việc xét ảnh hưởng của môi trường. Kỹ năng quái vật cũng có một số trait để có thể xét khắc chế khi tấn công người chơi. 
	
	\item Mỗi quái vật tồn tại nhờ một số bộ phận chí mạng gắn trên người, các bộ phận chí mạng này có thể là các bộ phận không thuộc quái vật nào. Quái vật nếu không còn bộ phận thật nào còn tồn tại sẽ bị tiêu diệt. Bộ phận chí mạng cũng là một thực thể của trò chơi, nghĩa là nó vẫn có mã định danh, tên và mô tả. Ngoài ra còn các thông số trạng thái như máu hiện tại. Các bộ phận này cũng có từ 1-3 traits để xét khắc chế khi người chơi tấn công.
	
	\item Traits là loại phẩm chất được sử dụng để xét khắc chế bởi đòn đánh của người chơi, quái vật, ảnh hưởng của môi trường. Trait có thể tồn tại ở bộ phận quái vật, loại quái vật, kỹ năng quái vật, trang bị, kỹ năng trang bị của người chơi. Trait bao gồm tên trait phân biệt, kèm mô tả trait đó. Một trait có thể là khắc chế của 0 hoặc nhiều trait khác, hoặc cũng có thể bị khắc chế của 0 hoặc nhiều trait.
	\item Để cung cấp clue cho người chơi, ngoài phản ứng của quái vật và hiệu ứng trả về của đòn đánh (Super/Not Really Effective), cơ sở dữ liệu của game cần có các bảng về các thông tin về quái vật như về chủng loại quái vật, traits,.... Ngoại hình của quái vật có khoá bao gồm mã định danh thực thể và category của ngoại hình, kèm với mô tả ngoại hình. Có thể có nhiều clue ứng với mỗi thực thể.
	
	\item Để có thể thực hiện các hành động như tấn công, sử dụng chiêu, sử dụng vật phẩm,... Có các bảng hỗ trợ để người chơi có thể đưa các tham số vào. Bảng Attack bao gồm các tham số là mã thực thể mục tiêu, mã trang bị sử dụng (cả mã định danh mục tiêu là khoá), người chơi có thể tấn công bằng trang bị hoặc bằng tay không đều được. Bảng Cast gồm hai thông số là mã kỹ năng sử dụng (đối tượng thi triển phải có kỹ năng mang kỹ năng này), kèm mã định danh của mục tiêu, nếu mục tiêu không có thì được xem là người thi triển muốn dùng kỹ năng cho mình. Bảng use bao gồm mã vật phẩm. Người chơi cần chèn các tham số vào bảng thì hành động mới có thể được thực thi.
	
\end{itemize}
\subsubsection{Giai đoạn 2: Thiết kế ý niệm của cơ sở dữ liệu}
\hspace*{0.5cm} Một trong những thứ không thể thiếu của game là schema của trò chơi. Người chơi sẽ sử dụng các câu truy vấn SQL để khai thác tối đa SQL, tìm được mục tiêu và tiêu diệt chúng.
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/EERD_v3.png}
	\vspace{0.5cm}
	\caption{Mô hình thực thể - quan hệ của cơ sở dữ liệu của màn chơi}
\end{figure}

\subsubsection{Giai đoạn 3: Lựa chọn Hệ quản trị cơ sở dữ liệu}
\hspace*{0.5cm} Ở giai đoạn này, cần lựa chọn Hệ quản trị cơ sở dữ liệu phù hợp với các tiêu chí đặt ra để game hoạt động đúng mục đích, đúng kỳ vọng. Để có thể xử lý câu truy vấn được nhập từ User, nhóm đã nghiên cứu các giải pháp sao cho có thể nhận câu SQL người chơi đã nhập, xử lý và trả kết quả về cho hệ thống xử lý và đưa ra các phản ứng của game. Một số tiêu chí được đưa ra:
\begin{itemize}
	\item \textbf{Về mặt kỹ thuật: } Hệ quản trị có thể nhận và xử lý câu truy vấn được nhập từ người dùng bằng ngôn ngữ SQL; Tốc độ xử lý đủ nhanh để trả kết quả hoặc phản ứng của game lên trên màn hình; Hệ quản trị nên được đặt trong nội bộ máy tính; Tính di động cao, Hệ quản trị vầ game có thể được chạy trên các nền tảng phần cứng khác nhau;
	\item \textbf{Về mặt phi kỹ thuật: } Tập trung chủ yếu vào chi phí mua các phần mềm để tích hợp việc xử lý SQL giữa Hệ quản trị cơ sở dữ liệu và ứng dụng game. 
\end{itemize}

\hspace*{0.5cm }Có rất nhiều hướng tiếp cập khác nhau. Nhưng nhóm cũng lựa chọn một số hướng tiếp cận nhất định.
\paragraph {Hướng tiếp cận sử dụng MySQL bằng cách thiết lập máy chủ cục bộ chạy trong máy người chơi}
\hspace*{0.5cm} Hướng tiếp cận này sử dụng một hệ quản trị cơ sở dữ liệu như MySQL hoặc tương tự và được chạy trong như một tiến trình máy chủ cục bộ độc lập và việc giao tiếp giữa Cơ sở dữ liệu và game là thông qua việc kết nối Hệ cơ sở dữ liệu thông qua localhost và một port nhất định. Việc thiết lập một máy chủ cục bộ chạy MySQL là riêng biệt. Về phía Game Client chỉ cần tạo một class \textit{SQLConnector}, truyền vào các tham số rồi kết nối đến máy chủ cục bộ đã thiết lập. Các câu truy vấn sẽ được connector này gọi truy vấn đến máy chủ cục bộ, kết quả hoặc lỗi cũng sẽ do connector này nhận và xử lý, truyền sang các lớp khác.\\
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/SQLLocalServer.png}
	\vspace{0.5cm}
	\caption{Mô hình cấu trúc của hướng giải pháp chạy SQL Server trên Local}
\end{figure}
\hspace*{0.5cm} Với việc sử dụng một process riêng, ta có thể tuỳ biến process theo dạng Hệ cơ sở dữ liệu SQL nào đều được, bao gồm MySQL, PostgreSQL,... Miễn là ta lựa chọn thư viện Database Client cho Connector phù hợp là được. Ta sẽ có toàn bộ chức năng như một hệ cơ sở dữ liệu thuần tuý, ta có thể thiết lập các stored procedure, function, thiết lập các quyền cho các user khác nhau cũng như nhiều tính năng hỗ trợ hơn.\\
\hspace*{0.5cm} Tuy nhiên, với việc sử dụng một process riêng và có sử dụng port. Nếu không xử lý port hợp lý, port mà process chiếm dụng sẽ không được sử dụng cho mục đích khác nữa. Hơn nữa, việc chạy localhost server bản chất vẫn là process, và nó có thể chấm dứt bởi trình quản lý tác vụ của hệ điều hành. Nếu mất đi kết nối với server local, game sẽ không thể thực thi các tác vụ có liên quan đến SQL, game sẽ không thể hoạt động và đó là điều không thể chấp nhận được. Hơn nữa, việc khởi chạy game đòi hỏi game cũng phải khởi chạy thêm tiến trình server. Cũng như khi cài đặt trò chơi, ta phải cài đặt thêm SQL Server. Khiến cho cấu trúc lủng củng, không nhất quán, đặc biệt là nếu SQL Server có sự cố thì game cũng không hoạt động được, dẫn đến chạy không ổn định.
\paragraph {Hướng tiếp cận xây dựng Hệ cơ sở dữ liệu SQLite ngay trong game}
\hspace*{0.5cm} Thay vì sử dụng một process riêng biệt, hướng tiếp cận này sử dụng SQLite, là một hệ cơ sở dữ liệu gọn nhẹ, có khả năng nhúng vào các ứng dụng khác. Đây là một ưu điểm lớn của SQLite khi nó có thể thực hiện các câu truy vấn ngay trong lòng ứng dụng, giúp cho cấu trúc được nhất quán và hoạt động đồng nhất và ổn định.
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/SQLITE.png}
	\vspace{0.5cm}
	\caption{Cấu trúc game với Hệ cơ sở dữ liệu SQLite}
\end{figure}
\hspace{0.5cm} Cách thiết lập cũng khá đơn giản, chỉ cần một file .db, và một module connector để kết nối với cơ sở dữ liệu cục bộ, connector cũng đóng vai trò thực hiện các câu truy vấn từ hệ thống và người chơi. 
\hspace*{0.5cm} Tuy nó có sự tiện lơi và gọn nhẹ và dễ dàng nhúng vào các ứng dụng khác, nhưng đổi lại, nó phải hy sinh nhiều tính năng. Trên hết là việc nó không hỗ trợ ràng buộc khoá ngoại tham chiếu đến nhiều bảng. Nó không hỗ trợ cấp quyền cho người dùng, nên việc xử lý các câu truy vấn của người dùng sẽ phải thêm một số bước mới có thể cho ra kết quả như kỳ vọng. Ngoài ra, với việc không có stored procedure cũng là một thiệt thòi lớn cho những ai muốn sử dụng procedure.\\
\hspace*{0.5cm} Bỏ qua những khuyết điẻm mà giải pháp này còn tồn đọng, nhóm vẫn quyết định sử dụng giải pháp này vì tính nhất quán và đồng nhất với dự án. Các vấn đề phát sinh nhóm sẽ có những cách xử lý khác nhau.
\subsubsection{Giai đoạn 4: Thiết kế cơ sở dữ liệu luận lý}
\hspace*{0.5cm} Từ những yêu cầu và cơ sở dữ liệu luận lý, nhóm bắt đầu thiết kế cơ sở dữ liệu luận lý, thể hiện các quan hệ và các ràng buộc về khoá ngoại.
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Schemav3.drawio.png}
	\vspace{0.5cm}
	\caption{Mô hình quan hệ - cơ sở dữ liệu luận lý trong màn chơi}
\end{figure}

\subsubsection{Giai đoạn 5: Thiết kế vật lý}
\hspace*{0.5cm} Từ schema diagram đã thiết kế ở giai đoạn trước, nhóm bắt đầu thiết kế cơ sở dữ liệu vật lý, thể hiện bằng các dòng code tương ứng với Hệ quản trị cơ sở dữ liệu nhóm đang sử dụng (ở đây là SQLite).\\
\begin{verbatim}
	DROP TABLE IF EXISTS Attack;
	DROP TABLE IF EXISTS Use;
	DROP TABLE IF EXISTS Cast;
	DROP TABLE IF EXISTS Skills;
	DROP TABLE IF EXISTS TypeHasSkills;
	DROP TABLE IF EXISTS LearnedSkills;
	DROP TABLE IF EXISTS Entities;
	DROP TABLE IF EXISTS HasTrait;
	DROP TABLE IF EXISTS Traits;
	DROP TABLE IF EXISTS TraitAdvOn;
	DROP TABLE IF EXISTS Knowledge;
	DROP TABLE IF EXISTS Equipment;
	DROP TABLE IF EXISTS HasType;
	DROP TABLE IF EXISTS MonsterType;
	DROP TABLE IF EXISTS Inventory;
	DROP TABLE IF EXISTS Stat;
	DROP TABLE IF EXISTS BattleLog;
	
	CREATE TABLE Entities (
	entityID      TEXT PRIMARY KEY,
	name          TEXT,
	description   TEXT,
	type          TEXT,
	parentID      TEXT,
	currentHP REAL,
	currentMaxHP REAL,
	level INTEGER,
	energyIndex REAL,
	statusFire REAL,
	statusIce REAL,
	statusPoison REAL,
	statusBlind REAL,
	FOREIGN KEY (parentID) 
	REFERENCES Entities (entityID) 
	ON DELETE SET NULL
	);
	CREATE TABLE Traits (
	traitName     TEXT PRIMARY KEY,
	description   TEXT
	);
	CREATE TABLE HasTrait (
	entityID      TEXT,
	trait         TEXT,
	PRIMARY KEY (entityID, trait),
	FOREIGN KEY (entityID) REFERENCES Entities(entityID) ON DELETE CASCADE,
	FOREIGN KEY (trait) REFERENCES Traits(traitName) ON DELETE CASCADE
	);
	CREATE TABLE TraitAdvOn (
	traitNameAdv     TEXT,
	traitNameDisAdv  TEXT,
	PRIMARY KEY (traitNameAdv, traitNameDisAdv),
	FOREIGN KEY (traitNameAdv) REFERENCES Traits (traitName)
	ON DELETE CASCADE
	ON UPDATE CASCADE,
	FOREIGN KEY (traitNameDisAdv) REFERENCES Traits (traitName)
	ON DELETE CASCADE
	ON UPDATE CASCADE
	);
	CREATE TABLE IF NOT EXISTS Stat (
	ownerID TEXT NOT NULL,
	statType TEXT NOT NULL,
	atk REAL DEFAULT 0,
	def REAL DEFAULT 0,
	magic REAL DEFAULT 0,
	maxHp REAL DEFAULT 0,
	hpmod REAL DEFAULT 0,
	critRate REAL DEFAULT 0,
	critBuff REAL DEFAULT 0,
	omnivamp REAL DEFAULT 0,
	agility REAL DEFAULT 0,
	atkFire REAL DEFAULT 0,
	atkIce REAL DEFAULT 0,
	atkPoison REAL DEFAULT 0,
	atkBlind REAL DEFAULT 0,
	resistFire REAL DEFAULT 0,
	resistIce REAL DEFAULT 0,
	resistPoison REAL DEFAULT 0,
	resistBlind REAL DEFAULT 0,
	PRIMARY KEY (ownerID, statType)
	);
	CREATE TABLE Skills (
	skillID TEXT PRIMARY KEY,
	skillName TEXT,
	skillDescription TEXT,
	skillCooldown INTEGER,
	skillCost REAL,
	trait1 TEXT DEFAULT NULL,
	trait2 TEXT DEFAULT NULL,
	FOREIGN KEY (trait1) REFERENCES Traits (traitName)
	ON DELETE SET NULL
	ON UPDATE CASCADE,
	FOREIGN KEY (trait2) REFERENCES Traits (traitName)
	ON DELETE SET NULL
	ON UPDATE CASCADE
	);
	CREATE TABLE Knowledge (
	entityID     TEXT,
	clue         TEXT,
	PRIMARY KEY (entityID, clue),
	FOREIGN KEY (entityID) REFERENCES Entities(entityID) ON DELETE CASCADE
	);
	CREATE TABLE Equipment (
	itemID       TEXT PRIMARY KEY,
	name         TEXT,
	type         TEXT,
	description  TEXT,
	level        INTEGER,
	trait1 TEXT DEFAULT NULL,
	trait2 TEXT DEFAULT NULL,
	trait3 TEXT DEFAULT NULL,
	FOREIGN KEY (trait1) REFERENCES Traits (traitName)
	ON DELETE SET NULL
	ON UPDATE CASCADE,
	FOREIGN KEY (trait2) REFERENCES Traits (traitName)
	ON DELETE SET NULL
	ON UPDATE CASCADE,
	FOREIGN KEY (trait3) REFERENCES Traits (traitName)
	ON DELETE SET NULL
	ON UPDATE CASCADE
	);
	CREATE TABLE Inventory (
	itemID       INTEGER PRIMARY KEY,
	quantity     INTEGER,
	name         TEXT,
	description  TEXT,
	type         TEXT,
	hpHeal REAL,
	buffATK REAL,
	buffDEF REAL,
	buffAgility REAL,
	fireEffectReduce REAL,
	iceEffectReduce REAL,
	poisonEffectReduce REAL,
	blindEffectReduce REAL
	);
	CREATE TABLE MonsterType (
	typeName     TEXT PRIMARY KEY,
	description  TEXT,
	trait1 TEXT DEFAULT NULL,
	trait2 TEXT DEFAULT NULL,
	trait3 TEXT DEFAULT NULL,
	FOREIGN KEY (trait1) REFERENCES Traits (traitName)
	ON DELETE SET NULL
	ON UPDATE CASCADE,
	FOREIGN KEY (trait2) REFERENCES Traits (traitName)
	ON DELETE SET NULL
	ON UPDATE CASCADE,
	FOREIGN KEY (trait3) REFERENCES Traits (traitName)
	ON DELETE SET NULL
	ON UPDATE CASCADE
	);
	CREATE TABLE HasType (
	entityID     TEXT,
	typeName     TEXT,
	PRIMARY KEY (entityID),
	FOREIGN KEY (entityID) REFERENCES Entities(entityID) ON DELETE CASCADE,
	FOREIGN KEY (typeName) REFERENCES MonsterType(typeName) ON DELETE SET NULL
	);
	CREATE TABLE TypeHasSkills (
	typeName     TEXT,
	skillID      TEXT,
	PRIMARY KEY (typeName, skillID),
	FOREIGN KEY (skillID) REFERENCES Skills(skillID) ON DELETE CASCADE,
	FOREIGN KEY (typeName) REFERENCES MonsterType(typeName) ON DELETE CASCADE
	);
	CREATE TABLE LearnedSkills (
	entityID     TEXT,
	skillID      TEXT,
	state        TEXT,
	PRIMARY KEY (entityID, skillID),
	FOREIGN KEY (entityID) REFERENCES Entities(entityID) ON DELETE CASCADE,
	FOREIGN KEY (skillID) REFERENCES Skills(skillID) ON DELETE CASCADE
	);
	
	CREATE TABLE Attack (
	targetEntityID TEXT PRIMARY KEY,
	itemID         TEXT,
	FOREIGN KEY (targetEntityID) REFERENCES Entities(entityID),
	FOREIGN KEY (itemID) REFERENCES Equipment(itemID)
	);
	CREATE TABLE Use (
	itemID TEXT PRIMARY KEY,
	targetEntityID TEXT,
	FOREIGN KEY (itemID) REFERENCES Inventory(itemID)
	FOREIGN KEY (targetEntityID) REFERENCES Entities(entityID)
	);
	CREATE TABLE Cast (
	skillID        TEXT PRIMARY KEY,
	targetEntityID TEXT,
	FOREIGN KEY (skillID) REFERENCES LearnedSkills(skillID),
	FOREIGN KEY (targetEntityID) REFERENCES Entities(entityID)
	);
\end{verbatim}
\hspace*{0.5cm} Ngoài ra nhóm còn thiết kế một số trigger phục vụ cho thao tác của người chơi và xử lý của hệ thống
\begin{verbatim}
	-- Drop old triggers if they exist
	DROP TRIGGER IF EXISTS trigger_attack_insert;
	DROP TRIGGER IF EXISTS trigger_use_insert;
	DROP TRIGGER IF EXISTS trigger_cast_insert;
	DROP TRIGGER IF EXISTS trigger_attack_clear;
	DROP TRIGGER IF EXISTS trigger_use_clear;
	DROP TRIGGER IF EXISTS trigger_cast_clear;
	
	-- Log table
	CREATE TABLE IF NOT EXISTS log_state (
	log TEXT PRIMARY KEY
	);
	
	-- Clear Attack before new insert
	CREATE TRIGGER trigger_attack_clear
	BEFORE INSERT ON Attack
	BEGIN
	DELETE FROM Attack;
	DELETE FROM log_state;
	END;
	
	-- Clear Use before new insert
	CREATE TRIGGER trigger_use_clear
	BEFORE INSERT ON Use
	BEGIN
	DELETE FROM Use;
	DELETE FROM log_state;
	END;
	
	-- Clear Cast before new insert
	CREATE TRIGGER trigger_cast_clear
	BEFORE INSERT ON Cast
	BEGIN
	DELETE FROM Cast;
	DELETE FROM log_state;
	END;
	
	-- Validate Attack insert
	CREATE TRIGGER trigger_attack_insert
	AFTER INSERT ON Attack
	FOR EACH ROW
	WHEN ((SELECT COUNT(*) FROM Attack) > 0 AND (SELECT COUNT(*) FROM log_state) == 0)
	BEGIN
	INSERT INTO log_state VALUES (
	CASE
	WHEN EXISTS (SELECT * FROM Entities WHERE entityID == NEW.targetEntityID)
	THEN        'AttackCode_legal_'
	ELSE 'AttackCode_illegal_'
	END
	);
	--    SELECT RAISE (ABORT, 'action detected');
	END;
	
	-- Validate Use insert
	CREATE TRIGGER trigger_use_insert
	AFTER INSERT ON Use
	FOR EACH ROW
	WHEN ((SELECT COUNT(*) FROM "Use") > 0 AND (SELECT COUNT(*) FROM log_state) = 0)
	BEGIN
	INSERT INTO log_state VALUES (
	CASE
	WHEN EXISTS (SELECT 1 FROM Inventory WHERE itemID = NEW.itemID)
	THEN 'UseCode_legal_'
	ELSE 'UseCode_illegal_'
	END
	);
	--    SELECT RAISE (ABORT, 'action detected');
	END;
	
	-- Validate Cast insert
	CREATE TRIGGER trigger_cast_insert
	AFTER INSERT ON Cast
	FOR EACH ROW
	WHEN ((SELECT COUNT(*) FROM Cast) > 0 AND (SELECT COUNT(*) FROM log_state) = 0)
	BEGIN
	INSERT INTO log_state VALUES (
	CASE
	WHEN EXISTS (SELECT 1 FROM LearnedSkills WHERE skillID = NEW.skillID)
	THEN 'CastCode_legal_'
	ELSE 'CastCode_illegal_'
	END
	);
	--    SELECT RAISE (ABORT, 'action detected');
	END;
\end{verbatim}

\subsection{Luật xử lý dựa trên hành động của người chơi}
\hspace*{0.5cm} Trong quá trình chơi, khó mà tránh khỏi việc người chơi có những hành vi cố ý tác động đến schema, nếu không xử lý hợp lý sẽ gây tình trạng màn chơi bị rối loạn, cũng như có thể dẫn đến mất ổn định game. Luôn nhớ rằng Schema chỉ là Playground của game, các object của game chỉ được quản lý bởi hệ thống, nên việc xử lý phải mang tính răn đe, cho người chơi nhớ được mọi hành vi của bản thân đều có thể mang lại hậu quả, tương tự với việc xử lý SQL trong công việc thực tế.\\

\hspace*{0.5cm} Với việc nhóm quyết định sử dụng SQLite và tích hợp thẳng vào game. Khiến nó bộc lộ hạn chế lớn: nó không hỗ trợ việc phân quyền. Vì vậy nhóm quyết định đặt ra các bộ quy tắc để xử lý ở mức DB Manager khi người chơi có các hành vi cụ thể với cấu trúc của cơ sở dữ liệu hoặc dữ liệu trong các bảng.
\subsubsection{Tạo, sửa, xoá bảng, trigger,...}
\hspace*{0.5cm} Hành vi tạo, sửa, xoá bảng hoặc các trigger của người chơi được xem là hành vi cấm. Song SQLite tích hợp vào Unity không hỗ trợ việc phân quyền và ngăn chặn các hành vi tạo, xoá, sửa bảng ở cấp Hệ quản trị cơ sở dữ liệu, nên việc xử lý này phải được thực hiện ở cấp ứng dụng, tức là game. Với mỗi câu truy vấn người chơi submit cho game, một module tên là SQLAnalyzer sẽ được gọi để kiểm tra xem câu lệnh có chứa các từ khoá như "CREATE", "DROP", "ALTER",... nếu có sẽ gọi báo lỗi và hiện lỗi lên trên màn hình và người chơi được phép nhập lại câu lệnh khác. 
\subsubsection{Thay đổi trạng thái của bảng}
\hspace*{0.5cm} Người chơi có thể tuỳ ý cập nhật, thêm, xoá record vào bất kỳ bảng nào trong Schema. Người dùng tự chịu trách nhiệm cho những gì người chơi đã thực hiện.

	
\subsubsection{Nhập vào nhiều câu truy vấn}
\hspace*{0.5cm} Mỗi lượt game chỉ chấp nhận một câu truy vấn từ người chơi. Trong trường hợp người chơi cố tình nhập nhiều câu lệnh theo đúng cấu trúc (các câu lệnh được ngăn cách nhau bằng dấu chấm phẩy ";") thì SQLAnalyzer sẽ phân tách thành các câu lệnh riêng và chọn câu lệnh được nhập vào đầu tiên để xử lý các bước tiếp theo. Đồng thời hiện thông báo người chơi đã nhập nhiều câu truy vấn trong một lượt, cũng như khung nhập câu truy vấn cũng đổi văn bản đã nhập thành câu lệnh đầu tiên.
\subsection{Thiết kế Class Diagram}
\subsubsection{IDBObjects}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/IDBOCD.drawio.png}
	\vspace{0.5cm}
	\caption{ Class Diagram của Cấu trúc IDBObject và các implement của nó}
\end{figure}
\subsubsection{Stats}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/StatsCD.drawio.png}
	\vspace{0.5cm}
	\caption{Class Diagram của Thông số}
\end{figure}
\subsubsection{Skills, Trait và MonsterType}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/traitCD.drawio.png}
	\vspace{0.5cm}
	\caption{Class Diagram của Trait, SKill và MonsterType}
\end{figure}
\subsubsection{Entity}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/EntityCD.drawio.png}
	\vspace{0.5cm}
	\caption{Class Diagram của Entity Manager}
\end{figure}
\subsubsection{Player}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/PlayerCD.drawio.png}
	\vspace{0.5cm}
	\caption{Class Diagram của Player}
\end{figure}
\subsubsection{Item System}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/ItemCD.drawio.png}
	\vspace{0.5cm}
	\caption{Class Diagram của Item System}
\end{figure}
\subsubsection{Monster}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/monsterCD.drawio.png}
	\vspace{0.5cm}
	\caption{Class Diagram của Monster và CriticalPart}
\end{figure}
\subsubsection{Combat System}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/CombatCD.drawio.png}
	\vspace{0.5cm}
	\caption{Class Diagram của Combat System}
\end{figure}
\subsubsection{Database System}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/CD/DBCD.drawio.png}
	\vspace{0.5cm}
	\caption{Class Diagram của Database System}
\end{figure}
\subsection{Cấu trúc module chính của Game}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/Module.jpg}
	\vspace{0.5cm}
	\caption{Module chính của trò chơi}
\end{figure}
\subsection{Sequence Diagram của việc nhập câu truy vấn của người chơi}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{Images/seqQuery.jpg}
	\vspace{0.5cm}
	\caption{Sequence Diagram dành cho việc nhập câu truy vấn từ người chơi}
\end{figure}

